#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_FluxSolverComponent

#include "Basic.hpp"

#include "BP_FluxSolverComponent_classes.hpp"
#include "BP_FluxSolverComponent_parameters.hpp"


namespace SDK
{

// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.AddOverlaping
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlapingActor                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::AddOverlaping(const class AActor*& OverlapingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "AddOverlaping");

	Params::BP_FluxSolverComponent_C_AddOverlaping Parms{};

	Parms.OverlapingActor = OverlapingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.ApplySimulationOffset
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_FluxSolverComponent_C::ApplySimulationOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "ApplySimulationOffset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.CanRenderInteractions
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanRender                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::CanRenderInteractions(bool* CanRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "CanRenderInteractions");

	Params::BP_FluxSolverComponent_C_CanRenderInteractions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanRender != nullptr)
		*CanRender = Parms.CanRender;
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.ExecuteUbergraph_BP_FluxSolverComponent
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::ExecuteUbergraph_BP_FluxSolverComponent(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "ExecuteUbergraph_BP_FluxSolverComponent");

	Params::BP_FluxSolverComponent_C_ExecuteUbergraph_BP_FluxSolverComponent Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.InitializeRenderTarget
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// ETextureAddress                         Repeat                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETextureFilter                          Filter                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::InitializeRenderTarget(class UTextureRenderTarget2D* TextureRenderTarget, ETextureAddress Repeat, ETextureFilter Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "InitializeRenderTarget");

	Params::BP_FluxSolverComponent_C_InitializeRenderTarget Parms{};

	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.Repeat = Repeat;
	Parms.Filter = Filter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.InitializeSimulation
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_FluxSolverComponent_C::InitializeSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "InitializeSimulation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.JumpToNextFrame
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTextureRenderTarget2D*           PrevFrame                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UTextureRenderTarget2D*           Param_CurrentFrame                                     (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UTextureRenderTarget2D*           NextFrame                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::JumpToNextFrame(class UTextureRenderTarget2D** PrevFrame, class UTextureRenderTarget2D** Param_CurrentFrame, class UTextureRenderTarget2D** NextFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "JumpToNextFrame");

	Params::BP_FluxSolverComponent_C_JumpToNextFrame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PrevFrame != nullptr)
		*PrevFrame = Parms.PrevFrame;

	if (Param_CurrentFrame != nullptr)
		*Param_CurrentFrame = Parms.Param_CurrentFrame;

	if (NextFrame != nullptr)
		*NextFrame = Parms.NextFrame;
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_FluxSolverComponent_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "ReceiveTick");

	Params::BP_FluxSolverComponent_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.RemoveOverlaping
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlapingActor                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::RemoveOverlaping(const class AActor*& OverlapingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "RemoveOverlaping");

	Params::BP_FluxSolverComponent_C_RemoveOverlaping Parms{};

	Parms.OverlapingActor = OverlapingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.UpdateFocusLocation
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_FluxSolverComponent_C::UpdateFocusLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "UpdateFocusLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.UpdateInteractions
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCanvas*                          Canvas                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ScreenSize                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Fraction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Part                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::UpdateInteractions(class UCanvas* Canvas, const struct FVector2D& ScreenSize, double Fraction, int32 Part)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "UpdateInteractions");

	Params::BP_FluxSolverComponent_C_UpdateInteractions Parms{};

	Parms.Canvas = Canvas;
	Parms.ScreenSize = std::move(ScreenSize);
	Parms.Fraction = Fraction;
	Parms.Part = Part;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.UpdateNormalMap
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture*                         HeightMap                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::UpdateNormalMap(class UTexture* HeightMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "UpdateNormalMap");

	Params::BP_FluxSolverComponent_C_UpdateNormalMap Parms{};

	Parms.HeightMap = HeightMap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.UpdateSimulation
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltTime                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_FluxSolverComponent_C::UpdateSimulation(double DeltTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "UpdateSimulation");

	Params::BP_FluxSolverComponent_C_UpdateSimulation Parms{};

	Parms.DeltTime = DeltTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.UpdateWorldPosition
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_FluxSolverComponent_C::UpdateWorldPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "UpdateWorldPosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_FluxSolverComponent.BP_FluxSolverComponent_C.RoundToPixel
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PixelSize                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector2D UBP_FluxSolverComponent_C::RoundToPixel(struct FVector2D& Location, int32 PixelSize) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_FluxSolverComponent_C", "RoundToPixel");

	Params::BP_FluxSolverComponent_C_RoundToPixel Parms{};

	Parms.Location = std::move(Location);
	Parms.PixelSize = PixelSize;

	UObject::ProcessEvent(Func, &Parms);

	Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}

}

