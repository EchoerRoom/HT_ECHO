#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SnappyRoad

#include "Basic.hpp"

#include "SnappyRoad_classes.hpp"
#include "SnappyRoad_parameters.hpp"


namespace SDK
{

// Function SnappyRoad.ComponentPoolManager.CleanPool
// (Final, Native, Public, BlueprintCallable)

void UComponentPoolManager::CleanPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentPoolManager", "CleanPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.ComponentPoolManager.GetComponentFromPool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UComponentPoolManager::GetComponentFromPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentPoolManager", "GetComponentFromPool");

	Params::ComponentPoolManager_GetComponentFromPool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.ComponentPoolManager.GetUsedComponentPool
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UComponentPoolManager::GetUsedComponentPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentPoolManager", "GetUsedComponentPool");

	Params::ComponentPoolManager_GetUsedComponentPool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.ComponentPoolManager.InitializePool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param_Outer                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComponentPoolManager::InitializePool(TSubclassOf<class UActorComponent> ComponentClass, class AActor* Param_Outer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentPoolManager", "InitializePool");

	Params::ComponentPoolManager_InitializePool Parms{};

	Parms.ComponentClass = ComponentClass;
	Parms.Param_Outer = Param_Outer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.ComponentPoolManager.ReturnAllComponentToPool
// (Final, Native, Public, BlueprintCallable)

void UComponentPoolManager::ReturnAllComponentToPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentPoolManager", "ReturnAllComponentToPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.ComponentPoolManager.ReturnComponentToPool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComponentPoolManager::ReturnComponentToPool(class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentPoolManager", "ReturnComponentToPool");

	Params::ComponentPoolManager_ReturnComponentToPool Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.ComponentPoolManager.ShrinkFreePool
// (Final, Native, Public, BlueprintCallable)

void UComponentPoolManager::ShrinkFreePool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComponentPoolManager", "ShrinkFreePool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.SnappyRoadComponent.Excute
// (Event, Public, BlueprintEvent)

void USnappyRoadComponent::Excute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoadComponent", "Excute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SnappyRoad.RoadFanceComponent.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USplineComponent*                 InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URoadFanceComponent::Initialize(struct FRoadFanceStruct& FanceStruct, class USplineComponent* InSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "Initialize");

	Params::RoadFanceComponent_Initialize Parms{};

	Parms.FanceStruct = std::move(FanceStruct);
	Parms.InSpline = InSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FanceStruct = std::move(Parms.FanceStruct);
}


// Function SnappyRoad.RoadFanceComponent.OffsetSpline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, NativeAccessSpecifierPublic)

void URoadFanceComponent::OffsetSpline(const struct FRoadFanceStruct& FanceStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "OffsetSpline");

	Params::RoadFanceComponent_OffsetSpline Parms{};

	Parms.FanceStruct = std::move(FanceStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.RoadFanceComponent.SetSplinePoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URoadFanceComponent::SetSplinePoints(struct FRoadFanceStruct& FanceStruct, const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "SetSplinePoints");

	Params::RoadFanceComponent_SetSplinePoints Parms{};

	Parms.FanceStruct = std::move(FanceStruct);
	Parms.Points = std::move(Points);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	FanceStruct = std::move(Parms.FanceStruct);
}


// Function SnappyRoad.RoadFanceComponent.UpdateSpline
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void URoadFanceComponent::UpdateSpline(struct FRoadFanceStruct* FanceStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "UpdateSpline");

	Params::RoadFanceComponent_UpdateSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FanceStruct != nullptr)
		*FanceStruct = std::move(Parms.FanceStruct);
}


// Function SnappyRoad.RoadFanceComponent.GetLocationAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, NativeAccessSpecifierPublic)
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URoadFanceComponent::GetLocationAtSplineInputKey(const struct FRoadFanceStruct& FanceStruct, float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "GetLocationAtSplineInputKey");

	Params::RoadFanceComponent_GetLocationAtSplineInputKey Parms{};

	Parms.FanceStruct = std::move(FanceStruct);
	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadFanceComponent.GetScaleAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, NativeAccessSpecifierPublic)
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URoadFanceComponent::GetScaleAtSplineInputKey(const struct FRoadFanceStruct& FanceStruct, float InKey) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "GetScaleAtSplineInputKey");

	Params::RoadFanceComponent_GetScaleAtSplineInputKey Parms{};

	Parms.FanceStruct = std::move(FanceStruct);
	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadFanceComponent.GetSplineLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URoadFanceComponent::GetSplineLength(const struct FRoadFanceStruct& FanceStruct) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "GetSplineLength");

	Params::RoadFanceComponent_GetSplineLength Parms{};

	Parms.FanceStruct = std::move(FanceStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadFanceComponent.GetTransformAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform URoadFanceComponent::GetTransformAtDistanceAlongSpline(const struct FRoadFanceStruct& FanceStruct, float Distance, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "GetTransformAtDistanceAlongSpline");

	Params::RoadFanceComponent_GetTransformAtDistanceAlongSpline Parms{};

	Parms.FanceStruct = std::move(FanceStruct);
	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadFanceComponent.GetTransformAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRoadFanceStruct                 FanceStruct                                            (Parm, NativeAccessSpecifierPublic)
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform URoadFanceComponent::GetTransformAtSplineInputKey(const struct FRoadFanceStruct& FanceStruct, float InKey, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadFanceComponent", "GetTransformAtSplineInputKey");

	Params::RoadFanceComponent_GetTransformAtSplineInputKey Parms{};

	Parms.FanceStruct = std::move(FanceStruct);
	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetCrosswalkMiddleIntersectionPoints
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FZoneShapePointInfo              PointInfo1                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FZoneShapePointInfo              PointInfo2                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          MiddleIntersectionPosition                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         MiddleIntersectionRotator                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FZoneLaneProfileRef              MiddleProfileRef                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FZoneShapePointInfo>      OutPointsInfo                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URoadNetworkUtility::GetCrosswalkMiddleIntersectionPoints(struct FZoneShapePointInfo* PointInfo1, struct FZoneShapePointInfo* PointInfo2, const struct FVector& MiddleIntersectionPosition, const struct FRotator& MiddleIntersectionRotator, const struct FZoneLaneProfileRef& MiddleProfileRef, TArray<struct FZoneShapePointInfo>* OutPointsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetCrosswalkMiddleIntersectionPoints");

	Params::RoadNetworkUtility_GetCrosswalkMiddleIntersectionPoints Parms{};

	Parms.MiddleIntersectionPosition = std::move(MiddleIntersectionPosition);
	Parms.MiddleIntersectionRotator = std::move(MiddleIntersectionRotator);
	Parms.MiddleProfileRef = std::move(MiddleProfileRef);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PointInfo1 != nullptr)
		*PointInfo1 = std::move(Parms.PointInfo1);

	if (PointInfo2 != nullptr)
		*PointInfo2 = std::move(Parms.PointInfo2);

	if (OutPointsInfo != nullptr)
		*OutPointsInfo = std::move(Parms.OutPointsInfo);

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetIntersectionConfig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntersectionConfig>      OutConfigs                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::GetIntersectionConfig(const class UStaticMesh* Mesh, TArray<struct FIntersectionConfig>* OutConfigs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetIntersectionConfig");

	Params::RoadNetworkUtility_GetIntersectionConfig Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConfigs != nullptr)
		*OutConfigs = std::move(Parms.OutConfigs);
}


// Function SnappyRoad.RoadNetworkUtility.GetIntersectionConfigByDirection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FIntersectionConfig>      IntersectionConfig                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// ERoadIntersectionDirection              Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Succeful                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntersectionConfig              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FIntersectionConfig URoadNetworkUtility::GetIntersectionConfigByDirection(const TArray<struct FIntersectionConfig>& IntersectionConfig, ERoadIntersectionDirection Direction, bool* Succeful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetIntersectionConfigByDirection");

	Params::RoadNetworkUtility_GetIntersectionConfigByDirection Parms{};

	Parms.IntersectionConfig = std::move(IntersectionConfig);
	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Succeful != nullptr)
		*Succeful = Parms.Succeful;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetIntersectionPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Point1                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Dir1                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point2                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Dir2                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          IntersectionPoint                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URoadNetworkUtility::GetIntersectionPoint(const struct FVector& Point1, const struct FVector& Dir1, const struct FVector& Point2, const struct FVector& Dir2, struct FVector* IntersectionPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetIntersectionPoint");

	Params::RoadNetworkUtility_GetIntersectionPoint Parms{};

	Parms.Point1 = std::move(Point1);
	Parms.Dir1 = std::move(Dir1);
	Parms.Point2 = std::move(Point2);
	Parms.Dir2 = std::move(Dir2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IntersectionPoint != nullptr)
		*IntersectionPoint = std::move(Parms.IntersectionPoint);

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetIntersectionTransform
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               OutTransform                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::GetIntersectionTransform(const class UStaticMesh* Mesh, TArray<struct FTransform>* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetIntersectionTransform");

	Params::RoadNetworkUtility_GetIntersectionTransform Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function SnappyRoad.RoadNetworkUtility.GetInverstDirection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ERoadIntersectionDirection              SourceDir                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoadIntersectionDirection              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERoadIntersectionDirection URoadNetworkUtility::GetInverstDirection(ERoadIntersectionDirection SourceDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetInverstDirection");

	Params::RoadNetworkUtility_GetInverstDirection Parms{};

	Parms.SourceDir = SourceDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetLaneProfileRefByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             LaneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Succeful                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FZoneLaneProfileRef              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FZoneLaneProfileRef URoadNetworkUtility::GetLaneProfileRefByName(class FName LaneName, bool* Succeful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetLaneProfileRefByName");

	Params::RoadNetworkUtility_GetLaneProfileRefByName Parms{};

	Parms.LaneName = LaneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Succeful != nullptr)
		*Succeful = Parms.Succeful;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetLanesTotalWidthByProfileRef
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FZoneLaneProfileRef              ProfileRef                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URoadNetworkUtility::GetLanesTotalWidthByProfileRef(const struct FZoneLaneProfileRef& ProfileRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetLanesTotalWidthByProfileRef");

	Params::RoadNetworkUtility_GetLanesTotalWidthByProfileRef Parms{};

	Parms.ProfileRef = std::move(ProfileRef);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetMidpointBetweenTwoPoints
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URoadNetworkUtility::GetMidpointBetweenTwoPoints(const struct FVector& Point1, const struct FVector& Point2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetMidpointBetweenTwoPoints");

	Params::RoadNetworkUtility_GetMidpointBetweenTwoPoints Parms{};

	Parms.Point1 = std::move(Point1);
	Parms.Point2 = std::move(Point2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetNextDirection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ERoadIntersectionDirection              SourceDir                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoadIntersectionDirection              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERoadIntersectionDirection URoadNetworkUtility::GetNextDirection(ERoadIntersectionDirection SourceDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetNextDirection");

	Params::RoadNetworkUtility_GetNextDirection Parms{};

	Parms.SourceDir = SourceDir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetSideRoadIntersectionPointInfo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntersectionConfig              SocketConfig1                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FIntersectionConfig              SocketConfig2                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          SideRoadOffsetAlongTrunkLane                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CrosswalkLinkOffset                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FZoneShapePointInfo>      OutPointsInfo                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URoadNetworkUtility::GetSideRoadIntersectionPointInfo(const struct FIntersectionConfig& SocketConfig1, const struct FIntersectionConfig& SocketConfig2, const struct FVector& SideRoadOffsetAlongTrunkLane, const struct FVector& CrosswalkLinkOffset, TArray<struct FZoneShapePointInfo>* OutPointsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetSideRoadIntersectionPointInfo");

	Params::RoadNetworkUtility_GetSideRoadIntersectionPointInfo Parms{};

	Parms.SocketConfig1 = std::move(SocketConfig1);
	Parms.SocketConfig2 = std::move(SocketConfig2);
	Parms.SideRoadOffsetAlongTrunkLane = std::move(SideRoadOffsetAlongTrunkLane);
	Parms.CrosswalkLinkOffset = std::move(CrosswalkLinkOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPointsInfo != nullptr)
		*OutPointsInfo = std::move(Parms.OutPointsInfo);

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetSocketsName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> URoadNetworkUtility::GetSocketsName(const class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetSocketsName");

	Params::RoadNetworkUtility_GetSocketsName Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetStraightConfig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FStraightConfig                  OutConfigs                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URoadNetworkUtility::GetStraightConfig(const class UStaticMesh* Mesh, struct FStraightConfig* OutConfigs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetStraightConfig");

	Params::RoadNetworkUtility_GetStraightConfig Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConfigs != nullptr)
		*OutConfigs = std::move(Parms.OutConfigs);

	return Parms.ReturnValue;
}


// Function SnappyRoad.RoadNetworkUtility.GetStraightTransform
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               OutTransform                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::GetStraightTransform(const class UStaticMesh* Mesh, TArray<struct FTransform>* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetStraightTransform");

	Params::RoadNetworkUtility_GetStraightTransform Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function SnappyRoad.RoadNetworkUtility.GetTrafficLightInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FIntersectionConfig>      Configs                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UTrafficlightConfigDataAsset*     TrafficTypeAsset                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTrafficLightInfo>        OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::GetTrafficLightInfo(const TArray<struct FIntersectionConfig>& Configs, const class UTrafficlightConfigDataAsset* TrafficTypeAsset, TArray<struct FTrafficLightInfo>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetTrafficLightInfo");

	Params::RoadNetworkUtility_GetTrafficLightInfo Parms{};

	Parms.Configs = std::move(Configs);
	Parms.TrafficTypeAsset = TrafficTypeAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function SnappyRoad.RoadNetworkUtility.GetTrunkIntersectionPointInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FIntersectionConfig>      SocketConfigs                                          (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FZoneShapePointInfo>      OutPointsInfo                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::GetTrunkIntersectionPointInfo(const TArray<struct FIntersectionConfig>& SocketConfigs, TArray<struct FZoneShapePointInfo>* OutPointsInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "GetTrunkIntersectionPointInfo");

	Params::RoadNetworkUtility_GetTrunkIntersectionPointInfo Parms{};

	Parms.SocketConfigs = std::move(SocketConfigs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPointsInfo != nullptr)
		*OutPointsInfo = std::move(Parms.OutPointsInfo);
}


// Function SnappyRoad.RoadNetworkUtility.SetIntersectionConfig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntersectionConfig>      Configs                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::SetIntersectionConfig(class UStaticMesh* Mesh, TArray<struct FIntersectionConfig>* Configs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "SetIntersectionConfig");

	Params::RoadNetworkUtility_SetIntersectionConfig Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Configs != nullptr)
		*Configs = std::move(Parms.Configs);
}


// Function SnappyRoad.RoadNetworkUtility.SetStraightConfig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FStraightConfig>          Configs                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::SetStraightConfig(class UStaticMesh* Mesh, TArray<struct FStraightConfig>* Configs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RoadNetworkUtility", "SetStraightConfig");

	Params::RoadNetworkUtility_SetStraightConfig Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Configs != nullptr)
		*Configs = std::move(Parms.Configs);
}


// Function SnappyRoad.RoadNetworkUtility.GetTrunkIntersectionSocketPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FIntersectionConfig>      Configs                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FSocketPoint>             OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URoadNetworkUtility::GetTrunkIntersectionSocketPoints(const TArray<struct FIntersectionConfig>& Configs, TArray<struct FSocketPoint>* OutPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoadNetworkUtility", "GetTrunkIntersectionSocketPoints");

	Params::RoadNetworkUtility_GetTrunkIntersectionSocketPoints Parms{};

	Parms.Configs = std::move(Configs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);
}


// Function SnappyRoad.SnappyRoad.AddExtraMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MeshExtraEnable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMeshExtra>               MeshExtra                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   YScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseRoll                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASnappyRoad::AddExtraMesh(class USplineComponent* Spline, bool MeshExtraEnable, const TArray<struct FMeshExtra>& MeshExtra, float YScale, bool UseRoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoad", "AddExtraMesh");

	Params::SnappyRoad_AddExtraMesh Parms{};

	Parms.Spline = Spline;
	Parms.MeshExtraEnable = MeshExtraEnable;
	Parms.MeshExtra = std::move(MeshExtra);
	Parms.YScale = YScale;
	Parms.UseRoll = UseRoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.SnappyRoad.AddInstancedSRC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class USnappyRoadComponent> Type                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USnappyRoadComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USnappyRoadComponent* ASnappyRoad::AddInstancedSRC(TSubclassOf<class USnappyRoadComponent> Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoad", "AddInstancedSRC");

	Params::SnappyRoad_AddInstancedSRC Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SnappyRoad.SnappyRoad.AddRoadSegments_C
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SegmentsNumber                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           MeshSegmentIndexes                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           MeshLengthCoefficients                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UStaticMesh*>              StaticMeshes                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMeshLegacy                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>                            MeshFlipY                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FlipY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewCullDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewCastShadow                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCollisionProfileName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseRoll                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UpdateMeshCollision                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseCustomTangents                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASnappyRoad::AddRoadSegments_C(class USplineComponent* Spline, int32 SegmentsNumber, const TArray<int32>& MeshSegmentIndexes, const TArray<float>& MeshLengthCoefficients, const TArray<class UStaticMesh*>& StaticMeshes, class UStaticMesh* StaticMeshLegacy, const TArray<bool>& MeshFlipY, const struct FVector& Offset, bool FlipY, bool UseScale, float YScale, float StartOffset, float EndOffset, float NewCullDistance, bool NewCastShadow, class FName InCollisionProfileName, bool UseRoll, bool UpdateMeshCollision, bool UseCustomTangents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoad", "AddRoadSegments_C");

	Params::SnappyRoad_AddRoadSegments_C Parms{};

	Parms.Spline = Spline;
	Parms.SegmentsNumber = SegmentsNumber;
	Parms.MeshSegmentIndexes = std::move(MeshSegmentIndexes);
	Parms.MeshLengthCoefficients = std::move(MeshLengthCoefficients);
	Parms.StaticMeshes = std::move(StaticMeshes);
	Parms.StaticMeshLegacy = StaticMeshLegacy;
	Parms.MeshFlipY = std::move(MeshFlipY);
	Parms.Offset = std::move(Offset);
	Parms.FlipY = FlipY;
	Parms.UseScale = UseScale;
	Parms.YScale = YScale;
	Parms.StartOffset = StartOffset;
	Parms.EndOffset = EndOffset;
	Parms.NewCullDistance = NewCullDistance;
	Parms.NewCastShadow = NewCastShadow;
	Parms.InCollisionProfileName = InCollisionProfileName;
	Parms.UseRoll = UseRoll;
	Parms.UpdateMeshCollision = UpdateMeshCollision;
	Parms.UseCustomTangents = UseCustomTangents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.SnappyRoad.AddRoadSegmentsSimple_C
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SegmentsNumber                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           MeshSegmentIndexes                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           MeshLengthCoefficients                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UStaticMesh*>              StaticMeshes                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMeshLegacy                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FlipY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewCullDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewCastShadow                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InCollisionProfileName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseRoll                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UpdateMeshCollision                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASnappyRoad::AddRoadSegmentsSimple_C(class USplineComponent* Spline, int32 SegmentsNumber, const TArray<int32>& MeshSegmentIndexes, const TArray<float>& MeshLengthCoefficients, const TArray<class UStaticMesh*>& StaticMeshes, class UStaticMesh* StaticMeshLegacy, const struct FVector& Offset, bool FlipY, bool UseScale, float YScale, float StartOffset, float EndOffset, float NewCullDistance, bool NewCastShadow, class FName InCollisionProfileName, bool UseRoll, bool UpdateMeshCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoad", "AddRoadSegmentsSimple_C");

	Params::SnappyRoad_AddRoadSegmentsSimple_C Parms{};

	Parms.Spline = Spline;
	Parms.SegmentsNumber = SegmentsNumber;
	Parms.MeshSegmentIndexes = std::move(MeshSegmentIndexes);
	Parms.MeshLengthCoefficients = std::move(MeshLengthCoefficients);
	Parms.StaticMeshes = std::move(StaticMeshes);
	Parms.StaticMeshLegacy = StaticMeshLegacy;
	Parms.Offset = std::move(Offset);
	Parms.FlipY = FlipY;
	Parms.UseScale = UseScale;
	Parms.YScale = YScale;
	Parms.StartOffset = StartOffset;
	Parms.EndOffset = EndOffset;
	Parms.NewCullDistance = NewCullDistance;
	Parms.NewCastShadow = NewCastShadow;
	Parms.InCollisionProfileName = InCollisionProfileName;
	Parms.UseRoll = UseRoll;
	Parms.UpdateMeshCollision = UpdateMeshCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.SnappyRoad.CreateTrafficLight
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTrafficlightConfigDataAsset*     TrafficTypeConfig                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ZoneShapeTransform                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASnappyRoad::CreateTrafficLight(class UStaticMesh* Mesh, const class UTrafficlightConfigDataAsset* TrafficTypeConfig, const struct FTransform& ZoneShapeTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoad", "CreateTrafficLight");

	Params::SnappyRoad_CreateTrafficLight Parms{};

	Parms.Mesh = Mesh;
	Parms.TrafficTypeConfig = TrafficTypeConfig;
	Parms.ZoneShapeTransform = std::move(ZoneShapeTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.SnappyRoad.DestoryInstancedSRC
// (Final, Native, Public, BlueprintCallable)

void ASnappyRoad::DestoryInstancedSRC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoad", "DestoryInstancedSRC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SnappyRoad.SnappyRoad.RegenerateCompontens
// (Final, Native, Public, BlueprintCallable)

void ASnappyRoad::RegenerateCompontens()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SnappyRoad", "RegenerateCompontens");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

